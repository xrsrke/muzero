# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/07_mcts.ipynb.

# %% auto 0
__all__ = ['ucb_score', 'Player', 'Node', 'dummy_model_predict']

# %% ../nbs/07_mcts.ipynb 4
import math
from typing import List, Tuple, Optional, Union, Dict, Literal
from enum import Enum

import torch
import gym

from .chess.game import get_init_board, place_piece, get_valid_moves, is_board_full, is_win

# %% ../nbs/07_mcts.ipynb 6
def ucb_score(parent, child):
    prior_score = child.prior_prob * math.sqrt(parent.visits) / (child.visits + 1)
    
    if child.visits > 0:
        value_score = child.value / child.visits
    else:
        value_score = 0
    
    return value_score + prior_score

# %% ../nbs/07_mcts.ipynb 7
class Player(Enum):
    BLACK = 1
    WHITE = -1

# %% ../nbs/07_mcts.ipynb 8
class Node:
    def __init__(self, prior_prob: float, player_turn: Player, state: torch.Tensor):
        """_summary_

        Args:
            prior_prob (float): _description_
            player_turn (_type_): _description_
            state (_type_): _description_
        
        Attr:
            children (Dict[int, Node]): a dictionary of child nodes, indexed by action
            value (Union[int, float]): the total reward value of all visits to this node
            visits (int): the number of times this node has been visited
        """
        self.prior_prob: float = prior_prob
        self.player_turn = player_turn
        self.state: torch.Tensor = state
        
        self.children: Dict[int, Node] = {}
        self.value: Union[int, float] = 0
        self.visits: int = 0
    
    def get_next_player_turn(self, current_turn: Player) -> Player:
        next_player_turn = Player.BLACK if current_turn == Player.WHITE else Player.WHITE
        return next_player_turn
    
    def expand(self, action_probs: List[float]):
        for action, prob in enumerate(action_probs):
            if prob > 0:
                next_player_turn = self.get_next_player_turn(self.player_turn)
                next_state = place_piece(board=self.state, player=next_player_turn.value, action=action)
                
                self.children[action] = Node(
                    prior_prob=prob,
                    player_turn=next_player_turn,
                    state=next_state
                )
    
    def select_child(self):
        max_score = -9999
        
        for action, child in self.children.items():
            score = ucb_score(self, child)
            
            if score > max_score:
                max_score = score
                selected_action = action
                selected_child = child
        
        return selected_action, selected_child

    # def ucb_score(self) -> Union[int, float]:
    #     """The UCB score of a node."""
    #     pass

# %% ../nbs/07_mcts.ipynb 16
def dummy_model_predict(board):
	value_head = 0.5
	action_probs = [0.5, 0, 0, 0, 0, 0.5, 0]
	return value_head, action_probs
